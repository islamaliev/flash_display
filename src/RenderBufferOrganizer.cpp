#include <cstring>
#include <ComponentContainer.h>
#include <Texture.h>
#include "Contex.h"
#include "RenderBufferOrganizer.h"
#include "StackAllocator.h"
#include "DisplayObject.h"
#include "Program.h"

using namespace flash;
using namespace render;

using Mat4 = math::Mat4;
using DisplayObject = display::DisplayObject;
using StackAllocator = allocator::StackAllocator;

namespace {
    class ForEachTextureDataIterator {
    public:
        ForEachTextureDataIterator(int& numLeafComponents, unsigned* batchSizes, int& lastDepth, unsigned& numDraws)
            : m_numLeafComponents(numLeafComponents)
            , m_batchSizes(batchSizes)
            , m_lastDepth(lastDepth)
            , m_numDraws(numDraws){}
        
        void operator()(TextureData& textureData, int depth) {
            if (depth <= 0)
                return;
            bool toOverride = m_lastDepth == depth - 1;
            m_lastDepth = depth;
            m_numLeafComponents += !toOverride;
            auto batchIndex = textureData.textureId  >> Context::s_batchBitsNum;
            m_batchSizes[batchIndex] = m_batchSizes[batchIndex] + !toOverride;
            m_numDraws = m_numDraws < batchIndex ? batchIndex : m_numDraws;
        }
        
    private:
        int& m_numLeafComponents;
        unsigned* m_batchSizes;
        int& m_lastDepth;
        unsigned& m_numDraws;
    };
    
    class ForEachIterator {
    public:
        ForEachIterator(Mat4* parentMatrices, int& lastDepth, int& lastIndex, BufferData& bufData, int* offsets)
            : m_parentMatrices(parentMatrices)
            , m_lastDepth(lastDepth)
            , m_lastIndex(lastIndex)
            , m_bufData(bufData)
            , m_offsets(offsets) {}
        
        void operator()(SpatialComponent& spatial, TextureData& textureData, int depth, int order) {
            if (depth <= 0)
                return;
            auto batchIndex = textureData.textureId >> Context::s_batchBitsNum;
            bool toOverride = m_lastDepth == depth - 1;
            // TODO: check if conditional move is used here
            auto index = toOverride ? m_lastIndex : m_offsets[batchIndex];
            // current batch offset advances once an object is added
            m_offsets[batchIndex] = m_offsets[batchIndex] + !toOverride;
            // for shapes the index is -1 so that it can be checked in ths frag shader
            // all other indices must be from 0 to GL_MAX_TEXTURE_IMAGE_UNITS
            m_bufData.textures[index] = textureData.textureId ? int(textureData.textureId - (batchIndex << Context::s_batchBitsNum)) : -1;
            Mat4* m = m_bufData.matrices + index;
            *m = m_parentMatrices[depth] = m_parentMatrices[depth - 1] * DisplayObject::_getTransform(spatial, order);
            m_lastDepth = depth;
            m_lastIndex = index;
        }
                
    private:
        Mat4* m_parentMatrices;
        int& m_lastDepth;
        int& m_lastIndex;
        BufferData& m_bufData;
        int* m_offsets;
    };
}

// TODO: find a way to get rid of this MAX_TREE_DEPTH
#define MAX_TREE_DEPTH 100

void RenderBufferOrganizer::organize(flash::display::DisplayObject& stage, StackAllocator& allocator, BufferData& bufData) {
    ComponentContainer& components = stage._getComponents();
    components.sort();
    
    const unsigned numTextures = display::Texture::s_numTextures + 1; // this includes shapes, e.g. objects with no texture
    // TODO: size of allocated memory should be numTextureGroups, not numTextures, nor numTextures >> Context::s_batchBitsNum
    // we don't control which texture id is generated by OpenGL. In the worst case all textures can fall in different groups
    unsigned* batchSizes = (unsigned*) allocator.alloc(sizeof(unsigned) * numTextures);
    memset(batchSizes, 0, sizeof(unsigned) * numTextures);

    int lastDepth = 1;
    int numLeafComponents = 0;
    unsigned numDraws = 0;

    components.forEachTextureData(ForEachTextureDataIterator(numLeafComponents, batchSizes, lastDepth, numDraws));

    bufData.batchSizes = batchSizes;
    bufData.numDraws = numDraws + 1;

    // offset for each batch
    int* offsets = (int*) allocator.alloc(sizeof(int) * numTextures);
    offsets[0] = 0;
    for (int i = 1; i < numTextures + 1; ++i) {
        offsets[i] = offsets[i - 1] + batchSizes[i - 1];
    }

    Mat4* parentMatrices = (Mat4*) allocator.alloc(sizeof(Mat4) * MAX_TREE_DEPTH);
    *parentMatrices = Mat4();

    bufData.matrices = (Mat4*) allocator.alloc(sizeof(Mat4) * numLeafComponents);
    bufData.textures = (int*) allocator.alloc(sizeof(Context::TextureIndexType) * numLeafComponents);

    lastDepth = 1;
    int lastIndex = 0;
    
    components.forEach(ForEachIterator(parentMatrices, lastDepth, lastIndex, bufData, offsets));
}